---
layout: post
title: "[이펙티브 자바 3판] 아이템18.상속보다는 컴포지션을 사용하라"
categories: [effective java]
date: 2020-03-03 19:25 +0900
published: true
---

![effective java image](https://user-images.githubusercontent.com/28615416/75598228-81ca1c00-5add-11ea-9319-e949af4e07cd.png){:.postImage}

메서드 호출과 달리 상속은 캡슐화를 깨드린다. 상위클래스가 어떻게 구현되느냐에 따라 하위 클래스의 동작에 이상이 생길 수 있다. 상위 클래스는 릴리즈마다 내부 구현이 달라질 수 있고, 그러 인해 코드 한줄 건드리지 않은 하위 클래스가 오작동 할 수 있다.

위의 문제는 메서드 재정의가 원인이었다. 따라서 클래스를 확장하더라도 메서드를 재정의하는 대신 새로운 메서드를 추가하면 괜찮으리라 생각할 수 있다. 이 방식이 안전하지만, 위험이 전혀 없는 것은 아니다. 다음 릴리즈에서 상위 클래스에 새 메서드가 추가 됐는데 운없게도 하필 여러분이 하위 클래스에 추가한 메서드와 시그니처가 같고 반환 타입은 다르다면 여러분의 클래스는 컴파일 조차 되지 않는다. 혹 반환 타입 마저 같다면 상위 클래스의 새 메서드 를 재정의한 꼴이니 앞서의 문제와 똑같은 상황에 부닥친다.
또한, 여러분이 이 메서드를 작성할 때는 상위 클래스의 메서드는 존재하지도 않았으니, 여러분이 만든 메서드는 상위 클래스의 메서드가 요구하는 규약을 만족하지 못할 가능성이 크다.

## 해결책

기존 클래스를 확장하는 대신, 새로운 클래스를 만들고 private 필드로 기존 클래스의 인스턴스를 참조하게 하자/ 기존 클래스가 새로운 클래스의 구성요소로 쓰인다는 뜻에서 이러한 설계를 컴포지션(구성) 이라 한다.

> 컴포지션과 전달의 조합은 넓은 의미로 위임이라고 부른다. 단, 엄밀히 래퍼 객체가 내부 객체에 자기 자신의 참조를 넘기는 경우만 위임에 해당 한다.

래퍼 클래스는 단점이 거의없다. 단 한가지 래퍼 클래스가 콜백 프레임워크와는 어울리지 않는다는 점만 주의하면 된다. 콜백 프레임워크에서는 자기 자신의 참조를 다른 객체에 넘겨서 다음 호출(콜백)때 사용하도록 한다. 내부 객체는 자신을 감싸고 있는 래퍼의 존재를 모르니 대신 자신(this)의 참조를 넘기고, 콜백 때는 래퍼가 아닌 내부 객체를 호출하게 된다. 이를 SELF문제라고 한다.

전달 메서드나 래퍼객체는 메모리 사용량에 주는 영향을 걱정하는 사람도 있지만, 실전에서는 둘 다 별다른 영향이 없다고 밝혀졌다.

전달 메서드를 작성하는 게 지루하겠지만, 재사용할 수 있는 전달 클래스를 인터페이스당 하나씩 만들어두면 원하는 기능을 덧씌우는 전달 클래스들을 아주 손쉽게 구현할 수 있다. 구아바는 모든 컬렉션 인터페이스용 전달 메서드를 전부 구현해뒀다.

컴포지션을 써야할 상황에서 상속을 사용하는 건 내부 구현을 불필요하게 노출하는 꼴이다.

컴포지션 대신 상속을 사용하기로 결정하기 전에 마지막으로 자문해야 할 질문을 소개한다. 확장하려는 클래스의 API에 아무런 결함이 없는가? 결함이 있다면 이 결함이 여러분 클래스의 API까지 전파돼도 괜찮은가? 컴포지션으로는 이런 결함을 숨기는 새로운 API를 설계할 수 있지만, 상속은 상위 클래스의 API를 그 결함까지도 그대로 계승한다.

## 핵심 정리

상속은 강력하지만 캡슐화를 해친다. is-a 관계일 때만 쓰자.
상속의 취약점을 피하려면 상속대신 컴포지션과 전달을 사용하자. 특히 래퍼 클래스로 구현할 적당한 인터페이스가 있다면 더욱 그렇다. 래퍼 클래스는 하위 클래스보다 견고하고 강력하다.
